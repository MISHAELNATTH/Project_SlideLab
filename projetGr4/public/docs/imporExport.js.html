

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> imporExport.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                <a
                    href="../index.html"
                    class="link"
                >
                    Retour vers SlideLab
                </a>
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Global</h3><ul><li><a href="global.html#addSlide">addSlide</a></li><li><a href="global.html#applyCameraTransform">applyCameraTransform</a></li><li><a href="global.html#applyTextFormatting">applyTextFormatting</a></li><li><a href="global.html#clamp">clamp</a></li><li><a href="global.html#cleanupLinksAfterSlideDelete">cleanupLinksAfterSlideDelete</a></li><li><a href="global.html#clearSelection">clearSelection</a></li><li><a href="global.html#configureDragDrop">configureDragDrop</a></li><li><a href="global.html#configureMoveResize">configureMoveResize</a></li><li><a href="global.html#configureThumbs">configureThumbs</a></li><li><a href="global.html#configureToolbars">configureToolbars</a></li><li><a href="global.html#createTextToolbar">createTextToolbar</a></li><li><a href="global.html#cryptoId">cryptoId</a></li><li><a href="global.html#debounce">debounce</a></li><li><a href="global.html#deleteSelected">deleteSelected</a></li><li><a href="global.html#deleteSlideByIndex">deleteSlideByIndex</a></li><li><a href="global.html#dom">dom</a></li><li><a href="global.html#endMove">endMove</a></li><li><a href="global.html#endResize">endResize</a></li><li><a href="global.html#getActive">getActive</a></li><li><a href="global.html#getElementClasses">getElementClasses</a></li><li><a href="global.html#getElementStyles">getElementStyles</a></li><li><a href="global.html#getSelectedId">getSelectedId</a></li><li><a href="global.html#getShapeWrapperStyles">getShapeWrapperStyles</a></li><li><a href="global.html#getSlideBackgroundStyle">getSlideBackgroundStyle</a></li><li><a href="global.html#getZoom">getZoom</a></li><li><a href="global.html#hrefToTarget">hrefToTarget</a></li><li><a href="global.html#initUI">initUI</a></li><li><a href="global.html#installCameraControls">installCameraControls</a></li><li><a href="global.html#installInteractions">installInteractions</a></li><li><a href="global.html#linkToSlideIndex">linkToSlideIndex</a></li><li><a href="global.html#loadSlidesStateFromLocalStorage">loadSlidesStateFromLocalStorage</a></li><li><a href="global.html#loadState">loadState</a></li><li><a href="global.html#lockPointerEvents">lockPointerEvents</a></li><li><a href="global.html#lockPointerEventsDeep">lockPointerEventsDeep</a></li><li><a href="global.html#onMove">onMove</a></li><li><a href="global.html#onResize">onResize</a></li><li><a href="global.html#px">px</a></li><li><a href="global.html#readSlideMeta">readSlideMeta</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#renderConnections">renderConnections</a></li><li><a href="global.html#renderNodes">renderNodes</a></li><li><a href="global.html#renderSidebar">renderSidebar</a></li><li><a href="global.html#renderThumbs">renderThumbs</a></li><li><a href="global.html#requestSave">requestSave</a></li><li><a href="global.html#saveSlidesStateToLocalStorage">saveSlidesStateToLocalStorage</a></li><li><a href="global.html#saveState">saveState</a></li><li><a href="global.html#searchEl">searchEl</a></li><li><a href="global.html#select">select</a></li><li><a href="global.html#setElementLinkInSlidesState">setElementLinkInSlidesState</a></li><li><a href="global.html#setSelectedId">setSelectedId</a></li><li><a href="global.html#setSlidePos">setSlidePos</a></li><li><a href="global.html#setSlideTitle">setSlideTitle</a></li><li><a href="global.html#setZoom">setZoom</a></li><li><a href="global.html#slideEl">slideEl</a></li><li><a href="global.html#slideId">slideId</a></li><li><a href="global.html#slideIndexToLink">slideIndexToLink</a></li><li><a href="global.html#startDrag">startDrag</a></li><li><a href="global.html#startMove">startMove</a></li><li><a href="global.html#startResize">startResize</a></li><li><a href="global.html#state">state</a></li><li><a href="global.html#stylesToString">stylesToString</a></li><li><a href="global.html#thumbsEl">thumbsEl</a></li><li><a href="global.html#zoomChip">zoomChip</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>imporExport.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * imporExport.js
 * Fonctions d'import/export du projet (JSON, HTML, ZIP si besoin).
 * Contient des helpers pour parser/transformer des fragments HTML,
 * nettoyer le HTML éditable, détecter des liens internes/externe,
 * et réinitialiser l'état de l'application lors d'un import.
 */
import { thumbsEl, state, slideId, setSelectedId, render, slideEl } from "./editor.js";
import { generateSlideHTML } from "./slides.js";

// =====================================================
//  HELPERS
// =====================================================

function pickNumberPx(style, prop, fallback = null) {
  // accepte: left: 90px; left:90px; left: 90.5px; left:-10px
  const re = new RegExp(`${prop}\\s*:\\s*(-?\\d+(?:\\.\\d+)?)px`, "i");
  const m = style.match(re);
  if (!m) return fallback;
  return parseFloat(m[1]);
}

function safeJsonParse(text) {
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}

function stripAfterTextToolbar(rawHtml) {
  if (!rawHtml) return rawHtml;

  // Coupe dès la première occurrence de &lt;div class="text-toolbar">
  const idx = rawHtml.indexOf('&lt;div class="text-toolbar"');
  if (idx === -1) return rawHtml;

  return rawHtml.slice(0, idx);
}

function cleanEditableHtml(node) {
  const clone = node.cloneNode(true);

  // supprime toolbars + handles si présents
  clone.querySelectorAll(".text-toolbar, .handle").forEach((el) => el.remove());

  // puis on coupe au cas où une toolbar serait restée en texte brut
  return stripAfterTextToolbar(clone.innerHTML);
}


/**
 * Convertit un href vers une "cible slide" (si détectable)
 * Supporte:
 *  - "slide-3.html"
 *  - "#slide:3"
 *  - "#slide-3"
 */
function hrefToTarget(href) {
  if (!href) return null;

  let m = href.match(/^#slide:(\d+)$/i);
  if (m) return { kind: "index", index: parseInt(m[1], 10) - 1 };

  m = href.match(/^#slide-(\d+)$/i);
  if (m) return { kind: "index", index: parseInt(m[1], 10) - 1 };

  m = href.match(/slide-(\d+)\.html$/i);
  if (m) {
    return {
      kind: "file",
      file: href,
      index: parseInt(m[1], 10) - 1
    };
  }

  return { kind: "href", href };
}

function hrefToLinkValue(href) {
  if (!href) return null;
  const s = String(href).trim();
  if (!s) return null;

  // Si c'est déjà un numéro (depuis data-link), on le garde
  if (/^\d+$/.test(s)) return s;

  // Externe => on garde tel quel
  if (/^https?:\/\//i.test(s)) return s;

  // Nos formats internes possibles
  let m = s.match(/^slide-(\d+)\.html$/i);
  if (m) return m[1]; // "slide-2.html" -> "2"

  m = s.match(/^#slide:(\d+)$/i);
  if (m) return m[1]; // "#slide:2" -> "2"

  m = s.match(/^#slide-(\d+)$/i);
  if (m) return m[1]; // "#slide-2" -> "2"

  // Sinon on garde (ex: "page.html" ou autre)
  return s;
}


/**
 * Lit le meta JSON si présent dans:
 * &lt;script id="slide-meta" type="application/json">...&lt;/script>
 */
function readSlideMeta(doc) {
  const metaNode = doc.querySelector('#slide-meta[type="application/json"]');
  if (!metaNode) return null;

  const meta = safeJsonParse(metaNode.textContent || "");
  if (!meta || typeof meta !== "object") return null;

  // normalisation minimale
  const title =
    typeof meta.title === "string" &amp;&amp; meta.title.trim()
      ? meta.title.trim()
      : null;

  const pos =
    meta.pos &amp;&amp;
    typeof meta.pos === "object" &amp;&amp;
    typeof meta.pos.x === "number" &amp;&amp;
    typeof meta.pos.y === "number"
      ? { x: meta.pos.x, y: meta.pos.y }
      : { x: 0, y: 0 };

  const buttonsMeta = Array.isArray(meta.buttons) ? meta.buttons : [];

  return {
    title,
    pos
  };
}

function readSlideBackgroundColor(doc) {
  const slide = doc.querySelector(".stage .slide");
  if (!slide) return null;

  const style = slide.getAttribute("style") || "";

  // 1) background-color
  let m = style.match(/background-color\s*:\s*([^;]+)/i);
  if (m) return m[1].trim();

  // 2) background (mais PAS gradient)
  m = style.match(/background\s*:\s*([^;]+)/i);
  if (m &amp;&amp; !m[1].includes("gradient")) {
    return m[1].trim();
  }

  return null;
}

function pickCssValue(style, prop, fallback = null) {
  // ex: background: #fff;  background-color: rgba(...);
  const re = new RegExp(`${prop}\\s*:\\s*([^;]+)`, "i");
  const m = style.match(re);
  return m ? m[1].trim() : fallback;
}

function pickOpacity(style, fallback = 1) {
  const v = pickCssValue(style, "opacity", null);
  const n = v != null ? parseFloat(v) : NaN;
  return Number.isFinite(n) ? n : fallback;
}

function detectShapeTypeFromClasses(classList) {
  const known = ["rectangle", "circle", "triangle", "star", "diamond"];
  for (const k of known) if (classList.contains(k)) return k;
  return "rectangle";
}

// ==============================
// IMPORT PROJECT (JSON with base64)
// ==============================
export function importProjectFromJSON(jsonText) {
  return new Promise((resolve, reject) => {
    // Laisse respirer le navigateur
    setTimeout(() => {
      try {
        const data = JSON.parse(jsonText);

        // Validation minimale
        if (!data || !Array.isArray(data.slides)) {
          reject("Structure JSON invalide");
          return;
        }

        // Remplacement TOTAL de l'état
        state.slides = data.slides;
        state.activeSlide = data.activeSlide ?? 0;

        // Nettoyage sélection
        setSelectedId(null);

        resolve();
      } catch (err) {
        reject(err);
      }
    }, 0);
  });
}



// =====================================================
//  PARSE HTML -> { elements, meta }
// =====================================================

function parseSlideHTML(htmlContent) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(htmlContent, "text/html");

  const meta = readSlideMeta(doc);
  const backgroundColor = readSlideBackgroundColor(doc);
  const elements = [];

  // 1) Nouveau format: .stage .slide .el
  const elsNew = doc.querySelectorAll(".slide .el");

  // 2) Ancien format: .slide-container .slide-element
  const elsOld = doc.querySelectorAll(".slide-container .slide-element");

  const nodes = elsNew.length ? elsNew : elsOld;

  nodes.forEach((node) => {
    const style = node.getAttribute("style") || "";

    const x = pickNumberPx(style, "left", 0);
    const y = pickNumberPx(style, "top", 0);
    const w = pickNumberPx(style, "width", 240);
    const h = pickNumberPx(style, "height", 54);

    let type = "text";
    let html = "";
    let imageData = null;

    // on essaie de garder l'id existant si export l’a mis (utile pour boutons)
    let id =
      node.getAttribute("data-id") ||
      node.getAttribute("data-btn-id") ||
      slideId();
    
    // --- Link detection ---
    // 1) Priorité: data-link (nouveau système)
    let link = node.getAttribute("data-link") || null;

    // 2) Fallback: l'élément contient un &lt;a href="..."> (ancien bouton ou wrapper interne)
    if (!link) {
      const aInside = node.querySelector?.("a[href]");
      if (aInside) link = aInside.getAttribute("href");
    }

    // 3) Fallback: l'élément est englobé par un &lt;a href="..."> (wrapper externe)
    if (!link) {
      const aParent = node.closest?.("a[href]");
      if (aParent) link = aParent.getAttribute("href");
    }

    link = hrefToLinkValue(link);



    // --- nouveau format (.el) ---
    if (node.classList.contains("el")) {
      if (node.classList.contains("text")) {
        type = "text";
        html = cleanEditableHtml(node) || "Texte";
      } else if (node.classList.contains("button")) {
        type = "button";
        html = node.innerHTML || "Bouton";
      } else if (node.classList.contains("shape")) {
        type = "shape";
      } else if (node.classList.contains("image")) {
        type = "image";
        const img = node.querySelector("img");
        if (type === "image" &amp;&amp; imageData) {
          // On garde seulement une info légère
          // si c'est une dataURL (base64), on stocke juste un nom placeholder
          if (imageData.startsWith("data:image/")) {
            obj.imageName = obj.imageName || "image_importee.png";
          } else {
            // si c'est déjà une URL/chemin relatif web, on le garde comme src
            obj.imageSrc = imageData;
          }
        }
      }
    }

    // --- ancien format (.slide-element) ---
    if (node.classList.contains("slide-element")) {
      if (node.classList.contains("text-element")) {
        type = "text";
        const p = node.querySelector("p");
        html = cleanEditableHtml(node) || "Texte";
      } else if (node.classList.contains("button-element")) {
        type = "button";
        html = node.innerHTML.trim() || "Bouton";
      } else if (node.classList.contains("shape-element")) {
        type = "shape";
      } else if (node.classList.contains("image-element")) {
        type = "image";
        const img = node.querySelector("img");
        if (img?.getAttribute("src")) imageData = img.getAttribute("src");
      }
    }

    const obj = {
      id,
      type,
      x: Math.round(x),
      y: Math.round(y),
      w: Math.round(w),
      h: Math.round(h),
      link,
      html
    };

    if (type === "image" &amp;&amp; imageData) obj.imageData = imageData;

    // --- SHAPE: récupérer couleur/bordure/opacity + shapeType ---
    if (type === "shape") {
      // shapeType via classes (car export ajoute el.shapeType en classe)
      obj.shapeType = detectShapeTypeFromClasses(node.classList);

      // fillColor: background-color puis background (si pas gradient)
      // Dans l'export, la couleur de la shape est mise sur
      // .shape-content-wrapper (wrapper interne). On tente donc
      // d'abord de lire le style de ce wrapper, puis on tombe
      // sur le style de l'élément parent si absent.
      const inner = node.querySelector('.shape-content-wrapper');
      const innerStyle = inner ? (inner.getAttribute('style') || '') : style;

      let bg = pickCssValue(innerStyle, "background-color", null);
      if (!bg) bg = pickCssValue(innerStyle, "background", null);

      // si c'est un gradient on garde quand même (ton app accepte background en fillColor)
      // MAIS si tu veux refuser les gradients, remplace par: if (bg?.includes("gradient")) bg = null;

      obj.fillColor = bg || "#7c5cff";          // fallback par défaut
      obj.borderColor = pickCssValue(innerStyle, "border-color", pickCssValue(style, "border-color", "#37d6ff"));
      obj.opacity = pickOpacity(innerStyle, pickOpacity(style, 1));
    }

    // --- TEXT / BUTTON: récupérer couleur, taille, police, alignement, style ---
    if (type === "text" || type === "button") {
      const color = pickCssValue(style, 'color', null);
      if (color) obj.color = color;

      const fs = pickNumberPx(style, 'font-size', null);
      if (fs !== null) obj.fontSize = Math.round(fs);

      const fw = pickCssValue(style, 'font-weight', null);
      if (fw) obj.fontWeight = fw;

      const ff = pickCssValue(style, 'font-family', null);
      if (ff) obj.fontFamily = ff.replace(/['\"]/g, '').trim();

      const ta = pickCssValue(style, 'text-align', null);
      if (ta) obj.textAlign = ta;

      const fst = pickCssValue(style, 'font-style', null);
      if (fst) obj.fontStyle = fst;
    }

    elements.push(obj);
  });

  // Si meta.buttons n’existe pas, on peut le reconstituer depuis le DOM (optionnel)
  // utile quand tu importes un vieux HTML sans meta.
  let buttonsMeta = meta?.buttonsMeta ?? null;
  if (!buttonsMeta) {
    const buttonNodes = elsNew.length
      ? doc.querySelectorAll(".slide .el.button")
      : doc.querySelectorAll(".slide-container .slide-element.button-element");

    buttonsMeta = Array.from(buttonNodes).map((btn) => {
      const buttonId =
        btn.getAttribute("data-btn-id") ||
        btn.getAttribute("data-id") ||
        slideId();

      const a = btn.querySelector("a[href]");
      const href = a ? a.getAttribute("href") : null;

      return {
        buttonId,
        href,
        target: hrefToTarget(href)
      };
    });
  }

  return {
    meta: {
      title: meta?.title ?? null,
      pos: meta?.pos ?? { x: 0, y: 0 },
      buttonsMeta
    },
    elements,
    backgroundColor
  };
}

// =====================================================
//  LOAD SLIDES FROM FILES
// =====================================================

function loadSlidesFromFiles(files) {
  const fileArray = Array.from(files).filter((f) => f.name.endsWith(".html"));

  if (fileArray.length === 0) {
    alert("No HTML files selected");
    return;
  }

  // tri pour un ordre stable
  fileArray.sort((a, b) => a.name.localeCompare(b.name));

  let loadedCount = 0;

  fileArray.forEach((file, index) => {
    const reader = new FileReader();

    reader.onload = (e) => {
      try {
        const htmlContent = e.target.result;

        const parsed = parseSlideHTML(htmlContent);
        const elements = parsed.elements;
        const meta = parsed.meta;

       const slideObj = {
        id: slideId(),
        elements,
        arbre: {
          title: meta.title ?? file.name.replace(/\.html$/i, ""),
          pos: meta.pos ?? { x: 0, y: 0 }
        },
        backgroundColor: parsed.backgroundColor || "#ffffff",
      };


        // Replace or add slide
        if (index === 0) {
          state.slides[state.activeSlide] = slideObj;
        } else {
          state.slides.push(slideObj);
        }

        loadedCount++;

        if (loadedCount === fileArray.length) {
          state.activeSlide = 0;
          setSelectedId(null);
          render();
          thumbsEl.scrollLeft = 0;
          alert(`✓ Loaded ${fileArray.length} slide(s)`);
        }
      } catch (error) {
        console.error("Error parsing file:", file.name, error);
      }
    };

    reader.readAsText(file);
  });
}

// =====================================================
//  UI: open folder button
// =====================================================

const fileInput = document.getElementById("fileInput");

document.getElementById("openFolderBtn").addEventListener("click", () => {
  fileInput.click();
});

fileInput.addEventListener("change", (ev) => {
  if (ev.target.files &amp;&amp; ev.target.files.length > 0) {
    loadSlidesFromFiles(ev.target.files);
    ev.target.value = ""; // reset input
  }
});


// export all slides as HTML files to download
document.getElementById("exportBtn").addEventListener("click", () => {
  
  state.slides.forEach((slide, index) => {
    const html = generateSlideHTML(index);
    const blob = new Blob([html], { type: "text/html" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = state.slides.length === 1 ? "slide.html" : `slide-${index + 1}.html`;

    setTimeout(() => {
      a.click();
      URL.revokeObjectURL(url);
    }, index * 200);
  });
  
});

// ==============================
// UI: IMPORT PROJECT BUTTON
// ==============================
const importBtn = document.getElementById("importProjectBtn");
const importInput = document.getElementById("importProjectInput");

if (importBtn &amp;&amp; importInput) {
  importBtn.addEventListener("click", () => {
    importInput.value = "";
    importInput.click();
  });

  importInput.addEventListener("change", () => {
    const file = importInput.files[0];
    if (!file) return;

    const reader = new FileReader();

    reader.onload = (e) => {
      importProjectFromJSON(e.target.result)
        .then(() => {
          render();
          thumbsEl.scrollLeft = 0;
          alert("✓ Projet importé avec succès");
        })
        .catch((err) => {
          console.error(err);
          alert("Erreur lors de l'import du projet");
        });
    };
    const importImagesInput = document.getElementById("importImagesInput");

    function relinkImagesWithFiles(files) {
      const map = new Map(Array.from(files).map(f => [f.name, f]));

      state.slides.forEach(slide => {
        (slide.elements || []).forEach(el => {
          if (el.type === "image" &amp;&amp; el.imageName) {
            const f = map.get(el.imageName);
            if (f) el.imageSrc = URL.createObjectURL(f);
          }
        });
      });
    }

    let waitingImages = false;

    importInput.addEventListener("change", () => {
      reader.onload = (e) => {
        importProjectFromJSON(e.target.result)
          .then(() => {
            waitingImages = true;
            importImagesInput.value = "";
            importImagesInput.click();
          })
          .catch(() => alert("Erreur import projet"));
      };
    });

    importImagesInput.addEventListener("change", (ev) => {
      if (!waitingImages) return;
      waitingImages = false;

      relinkImagesWithFiles(ev.target.files);
      render();
      thumbsEl.scrollLeft = 0;
      ev.target.value = "";
    });
    reader.readAsText(file);
  });
}


// ==============================
// UI: DOWNLOAD PROJECT (slides_state JSON)
// ==============================
const downloadProjectBtn = document.getElementById("downloadProjectBtn");

if (downloadProjectBtn) {
  downloadProjectBtn.addEventListener("click", () => {
    // On exporte l'état courant (sans toucher aux autres fichiers)
    const project = {
      activeSlide: state.activeSlide,
      slides: state.slides,
    };

    const json = JSON.stringify(project, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;

    // Nom de fichier propre
    const date = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    const fileName = `slides_state_${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(
      date.getDate()
    )}_${pad(date.getHours())}-${pad(date.getMinutes())}.json`;

    a.download = fileName;

    a.click();
    URL.revokeObjectURL(url);
  });
}

const exportPdfProjectBtn = document.getElementById("exportPdfProjectBtn");

if (exportPdfProjectBtn) {
  exportPdfProjectBtn.addEventListener("click", async () => {
    const { jsPDF } = window.jspdf;

    const slidesCount = state.slides.length;
    if (!slidesCount) {
      alert("Aucune slide à exporter");
      return;
    }

    const prev = state.activeSlide;

    const pdf = new jsPDF({
      orientation: "landscape",
      unit: "mm",
      format: "a4",
    });

    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();

    // petit helper pour attendre que le DOM se mette à jour
    const nextFrame = () => new Promise((r) => requestAnimationFrame(() => r()));
    const waitDOM = async () => { await nextFrame(); await nextFrame(); };

    for (let i = 0; i &lt; slidesCount; i++) {
      state.activeSlide = i;
      render();
      await waitDOM();

      const slideEl = document.getElementById("slide");
      if (!slideEl) {
        console.warn("Élément #slide introuvable");
        break;
      }

      // capture
      const canvas = await html2canvas(slideEl, {
        scale: 2,
        backgroundColor: null,
        useCORS: true,
      });

      const imgData = canvas.toDataURL("image/png");

      // calcul du scale pour rentrer dans A4
      const imgRatio = canvas.width / canvas.height;
      const pageRatio = pageWidth / pageHeight;

      let renderW, renderH;
      if (imgRatio > pageRatio) {
        renderW = pageWidth;
        renderH = pageWidth / imgRatio;
      } else {
        renderH = pageHeight;
        renderW = pageHeight * imgRatio;
      }

      const x = (pageWidth - renderW) / 2;
      const y = (pageHeight - renderH) / 2;

      // on ajoute la page APRES avoir une image valide
      if (i > 0) {
        pdf.addPage();
        pdf.setPage(pdf.getNumberOfPages());
      } else {
        pdf.setPage(1);
      }

      pdf.addImage(imgData, "PNG", x, y, renderW, renderH);
    }

    state.activeSlide = prev;
    render();

    pdf.save("SlideLab_projet.pdf");
  });
}
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
